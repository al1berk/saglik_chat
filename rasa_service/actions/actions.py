# actions/actions.py

from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from typing import Any, Text, Dict, List
import requests
import logging
import json
from datetime import datetime
from rasa_sdk.events import SlotSet, FollowupAction
import sys
import os

# MongoDB logger i√ßin path ekle
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from api_service.mongodb_logger import MongoDBLogger
from rasa_service.actions.api_clients import ClinicAPIClient, FlightAPIClient, HotelAPIClient


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# API Adresleri - 127.0.0.1 KULLAN (localhost yerine!)
API_SERVICE_URL = "http://127.0.0.1:8000/api"
OLLAMA_API_URL = "http://127.0.0.1:11434/api/generate"

PROXIES = {
    "http": None,
    "https": None,
}


# API Client'larƒ± ba≈ülat
clinic_client = ClinicAPIClient()
hotel_client = HotelAPIClient()
flight_client = FlightAPIClient()
# Timeout s√ºreleri (saniye) - AGRESƒ∞F D√ú≈û√úR√úLD√ú
API_TIMEOUT = 5  # API istekleri i√ßin 5 saniye (30s ‚Üí 5s)
OLLAMA_TIMEOUT = 30  # Ollama i√ßin 30 saniye (90s ‚Üí 30s)

CITY_NORMALIZATION = {
    # Antalya
    "antalya": "Antalya",
    "antalyada": "Antalya",
    "antalya'da": "Antalya",
    "antalyaya": "Antalya",
    "antalya'ya": "Antalya",
    "antalyadan": "Antalya",
    "antalya'dan": "Antalya",
    "antalyanƒ±n": "Antalya",
    "antalya'nƒ±n": "Antalya",
    
    # ƒ∞stanbul
    "istanbul": "ƒ∞stanbul",
    "istanbulda": "ƒ∞stanbul",
    "istanbul'da": "ƒ∞stanbul",
    "istanbula": "ƒ∞stanbul",
    "istanbul'a": "ƒ∞stanbul",
    "istanbuldan": "ƒ∞stanbul",
    "istanbul'dan": "ƒ∞stanbul",
    "istanbulun": "ƒ∞stanbul",
    "istanbul'un": "ƒ∞stanbul",

    # ƒ∞zmir
    "izmir": "ƒ∞zmir",
    "izmirde": "ƒ∞zmir",
    "izmir'de": "ƒ∞zmir",
    "izmire": "ƒ∞zmir",
    "izmir'e": "ƒ∞zmir",
    "izmirden": "ƒ∞zmir",
    "izmir'den": "ƒ∞zmir",
    "izmirin": "ƒ∞zmir",
    "izmir'in": "ƒ∞zmir",

    # Ankara
    "ankara": "Ankara",
    "ankarada": "Ankara",
    "ankara'da": "Ankara",
    "ankaraya": "Ankara",
    "ankara'ya": "Ankara",
    "ankaradan": "Ankara",
    "ankara'dan": "Ankara",
    "ankaranƒ±n": "Ankara",
    "ankara'nƒ±n": "Ankara"
}

def normalize_city(city: str) -> str:
    """≈ûehir ismini normalize et"""
    if not city:
        return None
    city_lower = city.lower().strip()
    return CITY_NORMALIZATION.get(city_lower, city.title())



class ActionAskOllama(Action):
    """Genel sorular i√ßin Ollama'ya sor - Rasa'nƒ±n anlayamadƒ±ƒüƒ± sorular buraya y√∂nlendirilir"""
    
    def name(self) -> Text:
        return "action_ask_ollama"

    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        user_message = tracker.latest_message.get('text', '')
        logger.info(f"ü§ñ Ollama'ya genel soru (fallback): '{user_message}'")

        # ‚úÖ T√úM CONTEXT Bƒ∞LGƒ∞LERƒ∞Nƒ∞ TOPLA
        # 1. Slot'lardan kullanƒ±cƒ± bilgileri
        tedavi_adi = tracker.get_slot("tedavi_adi")
        tedavi_turu = tracker.get_slot("tedavi_turu")
        sehir = tracker.get_slot("sehir")
        bolge = tracker.get_slot("bolge")
        butce = tracker.get_slot("butce")
        klinik_adi = tracker.get_slot("klinik_adi")
        tarih = tracker.get_slot("tarih")
        otel_kategori = tracker.get_slot("otel_kategori")
        ucus_sinifi = tracker.get_slot("ucus_sinifi")
        
        # 2. Sohbet ge√ßmi≈üini al (son 5 mesaj)
        conversation_history = []
        for event in list(tracker.events)[-10:]:  # Son 10 event'e bak
            if event.get('event') == 'user':
                conversation_history.append(f"Kullanƒ±cƒ±: {event.get('text', '')}")
            elif event.get('event') == 'bot':
                conversation_history.append(f"Bot: {event.get('text', '')[:100]}...")  # ƒ∞lk 100 karakter
        
        # 3. Context bilgisini zengin ≈üekilde olu≈ütur
        context_info = "\n\nüìã **KULLANICI PROFƒ∞Lƒ∞:**\n"
        
        if tedavi_adi or tedavi_turu:
            context_info += f"‚Ä¢ Tedavi: {tedavi_adi or tedavi_turu or 'Belirtilmemi≈ü'}\n"
        if sehir:
            context_info += f"‚Ä¢ ≈ûehir: {sehir}\n"
        if bolge:
            context_info += f"‚Ä¢ B√∂lge: {bolge}\n"
        if butce:
            context_info += f"‚Ä¢ B√ºt√ße: {butce}\n"
        if klinik_adi:
            context_info += f"‚Ä¢ ƒ∞lgilenilen Klinik: {klinik_adi}\n"
        if tarih:
            context_info += f"‚Ä¢ Tarih: {tarih}\n"
        if otel_kategori:
            context_info += f"‚Ä¢ Otel Tercihi: {otel_kategori}\n"
        if ucus_sinifi:
            context_info += f"‚Ä¢ U√ßu≈ü Sƒ±nƒ±fƒ±: {ucus_sinifi}\n"
        
        # Eƒüer hi√ß bilgi yoksa
        if context_info == "\n\nüìã **KULLANICI PROFƒ∞Lƒ∞:**\n":
            context_info = "\n\nüìã Kullanƒ±cƒ± hen√ºz profil bilgisi payla≈ümadƒ±.\n"
        
        # 4. Son 3 mesajƒ± ekle
        if conversation_history:
            context_info += f"\nüí¨ **SON MESAJLAR:**\n"
            for msg in conversation_history[-3:]:
                context_info += f"{msg}\n"

        # ‚úÖ GELƒ∞≈ûTƒ∞Rƒ∞LMƒ∞≈û PROMPT - Medikal Turizm Odaklƒ±
        prompt = f"""Sen T√ºrkiye'nin lider saƒülƒ±k turizmi ≈üirketinin AI asistanƒ±sƒ±n. Adƒ±n "Saƒülƒ±k Turizmi AI Asistan".

üéØ **UZMANLIKLARIN:**
- T√ºrkiye'deki t√ºm medikal tedavi t√ºrleri (di≈ü, estetik, g√∂z, ortopedi, kardiyoloji, obezite)
- Klinik ve hastane √∂nerileri (Antalya, ƒ∞stanbul, ƒ∞zmir, Ankara)
- Konaklama ve ula≈üƒ±m planlamasƒ±
- Fiyat bilgilendirme ve paket √∂nerileri
- Hasta haklarƒ± ve yasal s√ºre√ßler

üìå **√ñNEMLƒ∞ KURALLAR:**
1. ‚úÖ SADECE T√úRK√áE YANIT VER (hi√ß ƒ∞ngilizce kullanma)
2. ‚úÖ Kƒ±sa, samimi ve profesyonel ol (maksimum 5-6 c√ºmle)
3. ‚úÖ Sohbet akƒ±≈üƒ±nƒ± s√ºrd√ºr - context'i kullan
4. ‚ùå Kesin tanƒ±/tedavi √∂nerisi YAPMA - genel bilgi ver
5. ‚ùå Fiyat sorulursa "ortalama aralƒ±klar" ver (kesin fiyat verme)
6. ‚úÖ Kullanƒ±cƒ±nƒ±n ihtiyacƒ±nƒ± netle≈ütirici sorular sor

{context_info}

ü§î **≈ûƒ∞MDƒ∞Kƒ∞ SORU:** {user_message}

üí° **CEVABINI YAZ (T√ºrk√ße, samimi, yardƒ±mcƒ±):**"""
        
        data = {
            "model": "llama3",
            "prompt": prompt,
            "stream": False,
            "options": {
                "temperature": 0.7,  # Biraz daha yaratƒ±cƒ±
                "num_predict": 500,  # Daha uzun cevaplar
                "top_p": 0.9,
                "repeat_penalty": 1.3,
                "stop": ["KULLANICI", "USER:", "English:", "In English:", "Kullanƒ±cƒ±:", "SORU:"]
            }
        }

        dispatcher.utter_message(text="ü§î D√º≈ü√ºn√ºyorum...")

        try:
            response = requests.post(OLLAMA_API_URL, json=data, timeout=OLLAMA_TIMEOUT, proxies=PROXIES)
            response.raise_for_status()
            
            generated_text = response.json().get('response', '').strip()

            if generated_text:
                # Temizlik: Gereksiz ba≈ülƒ±klarƒ± kaldƒ±r
                generated_text = generated_text.replace("üí° CEVABINI YAZ:", "").strip()
                generated_text = generated_text.replace("CEVAP:", "").strip()
                
                dispatcher.utter_message(text=f"üí° {generated_text}")
                logger.info(f"‚úÖ Ollama fallback cevabƒ±: {len(generated_text)} karakter")
                
                # ‚úÖ Context'i g√ºncelle - b√ºt√ße, tarih gibi bilgileri slot'a kaydet
                slots_to_set = []
                
                # Basit entity extraction (rakamlar b√ºt√ße olabilir)
                import re
                numbers = re.findall(r'\b\d{4,5}\b', user_message)
                if numbers and not butce:
                    potential_budget = numbers[0]
                    slots_to_set.append(SlotSet("butce", potential_budget))
                    logger.info(f"üìä B√ºt√ße slot'una kaydedildi: {potential_budget}")
                
                return slots_to_set
            else:
                dispatcher.utter_message(text="√úzg√ºn√ºm, bu soruya ≈üu anda cevap veremiyorum. Daha spesifik sorular sorabilirsiniz:\n\nüí° √ñrnek sorular:\n‚Ä¢ 'Antalya'da di≈ü implantƒ± kliniƒüi'\n‚Ä¢ 'Rinoplasti fiyatlarƒ±'\n‚Ä¢ 'G√∂z ameliyatƒ± sonrasƒ± bakƒ±m'\n‚Ä¢ 'Otel √∂nerileri'")
                return []

        except requests.exceptions.ConnectionError:
            logger.error("‚ùå Ollama servisine baƒülanƒ±lamadƒ±")
            dispatcher.utter_message(text="‚ùå Yapay zeka servisi ≈üu anda √ßalƒ±≈ümƒ±yor.\n\n‚úÖ ≈ûunlarƒ± deneyebilirsiniz:\n‚Ä¢ 'Antalya'da klinik ara'\n‚Ä¢ 'Tedavi paketleri'\n‚Ä¢ 'Fiyat bilgisi'")
            return []
        except requests.exceptions.Timeout:
            logger.error(f"‚è±Ô∏è Ollama timeout ({OLLAMA_TIMEOUT}s)")
            dispatcher.utter_message(text="‚è±Ô∏è Cevap hazƒ±rlanƒ±rken zaman a≈üƒ±mƒ±. L√ºtfen tekrar deneyin veya daha spesifik soru sorun.")
            return []
        except Exception as e:
            logger.error(f"‚ùå Ollama hatasƒ±: {e}")
            dispatcher.utter_message(text="√úzg√ºn√ºm, ≈üu anda size yardƒ±mcƒ± olamƒ±yorum. L√ºtfen:\n‚Ä¢ Tedavi t√ºr√º belirtin\n‚Ä¢ ≈ûehir se√ßin\n‚Ä¢ B√ºt√ße bilgisi verin\n\nVe tekrar deneyin!")
            return []

class ActionLogConversation(Action):
    """
    HER MESAJDA √áALI≈ûIR - MongoDB'ye log atar
    Bu action'ƒ± domain.yml'de tanƒ±mlamanƒ±z gerekiyor
    """
    
    def name(self) -> Text:
        return "action_log_conversation"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        # MongoDB logger ba≈ülat
        mongo_logger = MongoDBLogger()
        
        try:
            # User bilgilerini al
            user_id = tracker.sender_id
            latest_message = tracker.latest_message
            
            # Intent ve entities
            intent_data = latest_message.get('intent', {})
            intent_name = intent_data.get('name')
            confidence = intent_data.get('confidence', 0.0)
            entities = latest_message.get('entities', [])
            
            # User mesajƒ±nƒ± kaydet
            if latest_message.get('text'):
                mongo_logger.log_message(
                    user_id=user_id,
                    sender="user",
                    text=latest_message['text'],
                    intent=intent_name,
                    entities=entities,
                    confidence=confidence
                )
                
                logger.info(f"‚úÖ MongoDB'ye kaydedildi: {user_id} - {intent_name}")
            
            # User profili g√ºncelle (entity'lerden bilgi √ßƒ±kar)
            user_updates = {}
            for entity in entities:
                entity_name = entity.get('entity')
                entity_value = entity.get('value')
                
                # Eƒüer ki≈üisel bilgi entity'si ise profili g√ºncelle
                if entity_name in ['yas', 'age']:
                    user_updates['age'] = int(entity_value) if isinstance(entity_value, (int, str)) else None
                elif entity_name in ['cinsiyet', 'gender']:
                    user_updates['gender'] = entity_value
                elif entity_name in ['isim', 'name']:
                    user_updates['name'] = entity_value
                elif entity_name in ['hastalik', 'health_condition']:
                    # Health conditions'ƒ± array olarak tut
                    existing_user = mongo_logger.get_user(user_id)
                    health_conditions = existing_user.get('health_conditions', []) if existing_user else []
                    if entity_value not in health_conditions:
                        health_conditions.append(entity_value)
                    user_updates['health_conditions'] = health_conditions
            
            # Preferences g√ºncelle (tedavi, ≈üehir, b√ºt√ße vb.)
            preferences = {}
            for entity in entities:
                entity_name = entity.get('entity')
                entity_value = entity.get('value')
                
                if entity_name in ['tedavi_adi', 'treatment']:
                    preferences['treatment'] = entity_value
                elif entity_name in ['sehir', 'city']:
                    preferences['city'] = entity_value
                elif entity_name in ['butce', 'budget']:
                    preferences['budget'] = entity_value
                elif entity_name in ['bolge', 'region']:
                    preferences['region'] = entity_value
            
            if preferences:
                user_updates['preferences'] = preferences
            
            # Eƒüer g√ºncellenecek bilgi varsa user'ƒ± g√ºncelle
            if user_updates:
                user_updates['user_id'] = user_id
                mongo_logger.upsert_user(user_updates)
                logger.info(f"‚úÖ User profili g√ºncellendi: {user_id}")
        
        except Exception as e:
            logger.error(f"‚ùå MongoDB logging hatasƒ±: {e}")
        
        finally:
            mongo_logger.close()
        
        return []


class ActionLogBotResponse(Action):
    """
    Bot cevabƒ±nƒ± MongoDB'ye kaydet
    """
    
    def name(self) -> Text:
        return "action_log_bot_response"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        mongo_logger = MongoDBLogger()
        
        try:
            user_id = tracker.sender_id
            
            # Son bot action'ƒ±nƒ± al
            events = tracker.events
            last_bot_action = None
            last_bot_message = None
            
            for event in reversed(events):
                if event.get('event') == 'action':
                    last_bot_action = event.get('name')
                    break
                elif event.get('event') == 'bot':
                    last_bot_message = event.get('text')
                    if last_bot_action:
                        break
            
            # Bot mesajƒ±nƒ± kaydet
            if last_bot_message:
                mongo_logger.log_message(
                    user_id=user_id,
                    sender="bot",
                    text=last_bot_message,
                    bot_action=last_bot_action
                )
                logger.info(f"‚úÖ Bot cevabƒ± kaydedildi: {last_bot_action}")
        
        except Exception as e:
            logger.error(f"‚ùå Bot response logging hatasƒ±: {e}")
        
        finally:
            mongo_logger.close()
        
        return []


class ActionSaveUserProfile(Action):
    """
    User profili kaydetme action'ƒ± (√∂nceki kodunuzda vardƒ±)
    ≈ûimdi MongoDB'ye kaydediyor
    """
    
    def name(self) -> Text:
        return "action_save_user_profile"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        mongo_logger = MongoDBLogger()
        
        try:
            user_id = tracker.sender_id
            
            # Slot'lardan user bilgilerini topla
            user_data = {
                "user_id": user_id,
                "name": tracker.get_slot("user_name"),
                "age": tracker.get_slot("yas"),
                "gender": tracker.get_slot("cinsiyet"),
                "preferences": {
                    "treatment": tracker.get_slot("tedavi_adi"),
                    "city": tracker.get_slot("sehir"),
                    "region": tracker.get_slot("bolge"),
                    "budget": tracker.get_slot("butce"),
                    "hotel_category": tracker.get_slot("otel_kategori"),
                    "flight_class": tracker.get_slot("ucus_sinifi")
                }
            }
            
            # Health conditions ekle
            hastalik = tracker.get_slot("hastalik")
            if hastalik:
                user_data["health_conditions"] = [hastalik] if isinstance(hastalik, str) else hastalik
            
            # MongoDB'ye kaydet
            mongo_logger.upsert_user(user_data)
            
            dispatcher.utter_message(text="‚úÖ Bilgileriniz g√ºvenle kaydedildi.")
            logger.info(f"‚úÖ User profili MongoDB'ye kaydedildi: {user_id}")
        
        except Exception as e:
            logger.error(f"‚ùå User profile kaydetme hatasƒ±: {e}")
            dispatcher.utter_message(text="‚ö†Ô∏è Bilgileriniz kaydedilirken bir sorun olu≈ütu.")
        
        finally:
            mongo_logger.close()
        
        return []


class ActionScheduleAppointment(Action):
    """
    Randevu olu≈ütur ve MongoDB'ye booking olarak kaydet
    """
    
    def name(self) -> Text:
        return "action_schedule_appointment"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        mongo_logger = MongoDBLogger()
        
        try:
            user_id = tracker.sender_id
            
            # Booking bilgilerini slot'lardan topla
            booking_data = {
                "user_id": user_id,
                "clinic_name": tracker.get_slot("klinik_adi") or "Belirtilmedi",
                "treatment": tracker.get_slot("tedavi_adi") or "Belirtilmedi",
                "hotel_name": tracker.get_slot("otel_kategori") or "Belirtilecek",
                "appointment_date": tracker.get_slot("tarih") or "Planlanacak",
                "status": "pending",
                "notes": f"B√ºt√ße: {tracker.get_slot('butce')}"
            }
            
            # MongoDB'ye kaydet
            booking_id = mongo_logger.create_booking(booking_data)
            
            message = f"‚úÖ Randevunuz olu≈üturuldu!\n\n"
            message += f"üìã Booking ID: {booking_id}\n"
            message += f"üè• Klinik: {booking_data['clinic_name']}\n"
            message += f"üíâ Tedavi: {booking_data['treatment']}\n"
            message += f"üìÖ Tarih: {booking_data['appointment_date']}\n\n"
            message += f"üìß Detaylƒ± bilgilendirme e-posta adresinize g√∂nderilecektir.\n"
            message += f"üì± Koordinat√∂r√ºm√ºz 24 saat i√ßinde sizinle ileti≈üime ge√ßecektir."
            
            dispatcher.utter_message(text=message)
            logger.info(f"‚úÖ Booking olu≈üturuldu: {booking_id}")
        
        except Exception as e:
            logger.error(f"‚ùå Appointment scheduling hatasƒ±: {e}")
            dispatcher.utter_message(text="‚ö†Ô∏è Randevu olu≈üturulurken bir sorun olu≈ütu.")
        
        finally:
            mongo_logger.close()
        
        return []








# ============ Fƒ∞YAT HESAPLAMA FONKSƒ∞YONU ============
def calculate_treatment_price(treatment_name, clinic_rating):
    """Tedavi fiyatƒ±nƒ± hesapla"""
    base_prices = {
        "dental implant": 1500,
        "rhinoplasty": 3500,
        "cataract": 2000,
        "sleeve gastrectomy": 4500,
        "knee replacement": 8000,
        "laser varicose vein": 1800,
        "teeth whitening": 300,
        "botox": 400,
        "face lift": 5000,
        "breast surgery": 4000
    }
    
    base_price = base_prices.get(treatment_name.lower(), 2000)
    # Klinik rating'e g√∂re fiyat artƒ±≈üƒ±
    rating_multiplier = 1 + (clinic_rating - 4.5) * 0.2
    
    return int(base_price * rating_multiplier)

def calculate_hotel_price(hotel_info, nights=7):
    """Otel fiyatƒ±nƒ± hesapla"""
    base_prices = {
        "standard": 100,
        "premium": 200,
        "luxury": 400
    }
    
    price_per_night = base_prices.get(hotel_info.get("price_range", "standard"), 150)
    return price_per_night * nights

def calculate_flight_price(flight_class, flight_type):
    """U√ßu≈ü fiyatƒ±nƒ± hesapla"""
    base_prices = {
        "economy": 300,
        "business": 1200
    }
    
    price = base_prices.get(flight_class, 300)
    if flight_type == "direct":
        price *= 1.3
    
    return int(price)


# ============ CUSTOM ACTIONS ============

class ActionSearchClinicsByTreatment(Action):
    """Tedavi t√ºr√ºne g√∂re klinik ara - API Client kullanƒ±yor"""
    
    def name(self) -> Text:
        return "action_search_clinics_by_treatment"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        tedavi_adi = tracker.get_slot("tedavi_adi")
        tedavi_turu = tracker.get_slot("tedavi_turu")
        sehir = normalize_city(tracker.get_slot("sehir"))
        
        # Tedavi t√ºr√ºn√º belirle
        if not tedavi_turu and tedavi_adi:
            dental_treatments = ["implant", "whitening", "veneers", "orthodontics", "root canal"]
            aesthetic_treatments = ["rhinoplasty", "botox", "face lift", "breast"]
            eye_treatments = ["cataract", "glaucoma", "retinal"]
            
            tedavi_lower = tedavi_adi.lower()
            if any(t in tedavi_lower for t in dental_treatments):
                tedavi_turu = "dental"
            elif any(t in tedavi_lower for t in aesthetic_treatments):
                tedavi_turu = "aesthetic"
            elif any(t in tedavi_lower for t in eye_treatments):
                tedavi_turu = "eye_care"
        
        try:
            response = clinic_client.search_clinics(
                treatment_type=tedavi_turu,
                city=sehir,
                treatment_name=tedavi_adi
            )
            
            clinics = response.get("results", [])
            
            if clinics:
                message = f"‚úÖ {sehir} i√ßin {len(clinics)} klinik bulundu!\n\n"
                
                for clinic in clinics[:3]:  # ƒ∞lk 3 klinik g√∂ster
                    message += f"üè• **{clinic['name']}**\n"
                    message += f"   üìç {clinic['district']}\n"
                    message += f"   ‚≠ê {clinic['rating']}/5.0\n"
                    message += f"   üíâ Tedaviler: {', '.join(clinic['treatments'][:3])}\n\n"
                
                dispatcher.utter_message(text=message)
            else:
                dispatcher.utter_message(
                    text=f"√úzg√ºn√ºm, {sehir}'da bu tedavi i√ßin klinik bulunamadƒ±."
                )
                
        except Exception as e:
            logger.error(f"‚ùå Klinik arama hatasƒ±: {e}")
            dispatcher.utter_message(
                text="‚ö†Ô∏è Klinik bilgileri alƒ±nƒ±rken bir hata olu≈ütu."
            )
        
        return [SlotSet("tedavi_turu", tedavi_turu)]


class ActionSearchClinicsByLocation(Action):
    """Lokasyona g√∂re klinik ara"""
    
    def name(self) -> Text:
        return "action_search_clinics_by_location"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        sehir = tracker.get_slot("sehir")
        bolge = tracker.get_slot("bolge")
        
        message = f"üìç {sehir}"
        if bolge:
            message += f" - {bolge} b√∂lgesi"
        message += " i√ßin klinikler aranƒ±yor..."
        
        dispatcher.utter_message(text=message)
        
        return []


class ActionSearchHotelsByRegion(Action):
    """B√∂lgeye g√∂re otel ara - API Client kullanƒ±yor"""
    
    def name(self) -> Text:
        return "action_search_hotels_by_region"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        bolge = tracker.get_slot("bolge")
        otel_kategori = tracker.get_slot("otel_kategori")
        
        # Yƒ±ldƒ±z sayƒ±sƒ±nƒ± belirle
        stars = 5 if otel_kategori and "5" in otel_kategori else 4
        
        # ‚úÖ API CLIENT KULLAN
        try:
            response = hotel_client.search_hotels(
                region=bolge,
                stars=stars
            )
            
            hotels = response.get("results", [])
            
            if hotels:
                message = f"üè® {bolge} b√∂lgesinde {len(hotels)} otel bulundu!\n\n"
                
                for hotel in hotels[:3]:  # ƒ∞lk 3 otel g√∂ster
                    message += f"üè® **{hotel['name']}**\n"
                    message += f"   {'‚≠ê' * hotel['stars']}\n"
                    message += f"   üí∞ {hotel.get('price_per_night', 'Fiyat bilgisi yok')} EUR/gece\n"
                    message += f"   ‚ú® {', '.join(hotel['features'][:3])}\n\n"
                
                dispatcher.utter_message(text=message)
            else:
                dispatcher.utter_message(
                    text=f"√úzg√ºn√ºm, {bolge}'de uygun otel bulunamadƒ±."
                )
                
        except Exception as e:
            logger.error(f"‚ùå Otel arama hatasƒ±: {e}")
            dispatcher.utter_message(
                text="‚ö†Ô∏è Otel bilgileri alƒ±nƒ±rken bir hata olu≈ütu."
            )
        
        return []


class ActionGenerateBundleRecommendation(Action):
    """Yapay zeka destekli paket √∂nerisi olu≈ütur - API Client kullanƒ±yor"""
    
    def name(self) -> Text:
        return "action_generate_bundle_recommendation"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        # Kullanƒ±cƒ± bilgilerini topla
        user_profile = {
            "tedavi_turu": tracker.get_slot("tedavi_turu"),
            "tedavi_adi": tracker.get_slot("tedavi_adi"),
            "sehir": normalize_city(tracker.get_slot("sehir")),
            "bolge": tracker.get_slot("bolge"),
            "tarih": tracker.get_slot("tarih"),
            "butce": tracker.get_slot("butce"),
            "otel_kategori": tracker.get_slot("otel_kategori"),
            "ucus_sinifi": tracker.get_slot("ucus_sinifi") or "economy",
            "ucus_tipi": tracker.get_slot("ucus_tipi") or "connecting"
        }
        
        dispatcher.utter_message(text="üîç Sizin i√ßin en uygun paketler hazƒ±rlanƒ±yor...")
        
        try:
            # ‚úÖ API CLIENT'LARI KULLAN
            # 1. Klinik ara
            clinic_response = clinic_client.search_clinics(
                treatment_type=user_profile["tedavi_turu"],
                city=user_profile["sehir"]
            )
            clinics = clinic_response.get("results", [])[:3]
            
            # 2. Otel ara
            hotel_response = hotel_client.search_hotels(
                region=user_profile["bolge"] or "Lara",
                stars=5
            )
            hotels = hotel_response.get("results", [])[:3]
            
            # 3. U√ßu≈ü ara
            flight_response = flight_client.search_flights(
                flight_class=user_profile["ucus_sinifi"]
            )
            flights = flight_response.get("results", [])[:3]
            
            # Paketleri olu≈ütur
            bundles = []
            for i in range(min(3, len(clinics))):
                clinic = clinics[i] if i < len(clinics) else clinics[0]
                hotel = hotels[i] if i < len(hotels) else hotels[0]
                flight = flights[i] if i < len(flights) else flights[0]
                
                # Fiyat hesapla
                treatment_price = calculate_treatment_price(
                    user_profile.get("tedavi_adi", "dental treatment"),
                    clinic.get("rating", 4.5)
                )
                hotel_price = calculate_hotel_price(hotel, nights=7)
                flight_price = flight.get("price", 300)
                transfer_price = 150
                
                total_price = treatment_price + hotel_price + (flight_price * 2) + transfer_price
                
                bundles.append({
                    "name": f"Paket {i+1} - {['Ekonomik', 'Standart', 'Premium'][i]}",
                    "clinic": clinic["name"],
                    "clinic_rating": clinic["rating"],
                    "hotel": hotel["name"],
                    "hotel_stars": hotel["stars"],
                    "flight": flight.get("airline", "Turkish Airlines"),
                    "treatment_price": treatment_price,
                    "hotel_price": hotel_price,
                    "flight_price": flight_price * 2,
                    "transfer_price": transfer_price,
                    "total_price": total_price,
                    "currency": "EUR"
                })
            
            # Paketleri g√∂ster
            message = "üéÅ **Sizin ƒ∞√ßin √ñzel Hazƒ±rlanan Paketler:**\n\n"
            
            for bundle in bundles:
                message += f"**{bundle['name']}** - {bundle['total_price']} {bundle['currency']}\n"
                message += f"üè• Klinik: {bundle['clinic']} (‚≠ê{bundle['clinic_rating']})\n"
                message += f"üè® Otel: {bundle['hotel']} ({'‚≠ê' * bundle['hotel_stars']})\n"
                message += f"‚úàÔ∏è U√ßu≈ü: {bundle['flight']}\n"
                message += f"üí∞ Detaylar:\n"
                message += f"   ‚Ä¢ Tedavi: {bundle['treatment_price']} EUR\n"
                message += f"   ‚Ä¢ Konaklama (7 gece): {bundle['hotel_price']} EUR\n"
                message += f"   ‚Ä¢ U√ßu≈ü (Gidi≈ü-D√∂n√º≈ü): {bundle['flight_price']} EUR\n"
                message += f"   ‚Ä¢ Transfer: {bundle['transfer_price']} EUR\n"
                message += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            
            message += "‚úÖ T√ºm paketler ≈üunlarƒ± i√ßerir:\n"
            message += "‚Ä¢ Havalimanƒ± kar≈üƒ±lama ve transferler\n"
            message += "‚Ä¢ 7/24 T√ºrk√ße asistan desteƒüi\n"
            message += "‚Ä¢ √ñn kons√ºltasyon\n"
            message += "‚Ä¢ Kontrol muayeneleri\n\n"
            message += "Hangi paketi se√ßmek istersiniz?"
            
            dispatcher.utter_message(text=message)
            
        except Exception as e:
            logger.error(f"‚ùå Paket olu≈üturma hatasƒ±: {e}")
            dispatcher.utter_message(
                text="‚ö†Ô∏è Paket hazƒ±rlanƒ±rken bir hata olu≈ütu. L√ºtfen tekrar deneyin."
            )
        
        return []


class ActionCalculatePackagePrice(Action):
    """Paket fiyatƒ±nƒ± hesapla ve g√∂ster"""
    
    def name(self) -> Text:
        return "action_calculate_package_price"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        tedavi_adi = tracker.get_slot("tedavi_adi") or "dental treatment"
        
        # Basit fiyat hesaplama
        base_price = calculate_treatment_price(tedavi_adi, 4.7)
        hotel_price = 700  # 7 gece ortalama
        flight_price = 600  # Gidi≈ü-d√∂n√º≈ü
        transfer_price = 150
        
        total = base_price + hotel_price + flight_price + transfer_price
        
        message = f"üí∞ **Fiyat Detaylarƒ±:**\n\n"
        message += f"‚Ä¢ Tedavi: {base_price} EUR\n"
        message += f"‚Ä¢ Otel (7 gece): {hotel_price} EUR\n"
        message += f"‚Ä¢ U√ßu≈ü: {flight_price} EUR\n"
        message += f"‚Ä¢ Transfer: {transfer_price} EUR\n"
        message += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        message += f"**TOPLAM: {total} EUR**\n\n"
        message += f"‚ú® √ñdeme se√ßenekleri:\n"
        message += f"‚Ä¢ Pe≈üin √∂deme (5% indirim)\n"
        message += f"‚Ä¢ 3 taksit (komisyonsuz)\n"
        message += f"‚Ä¢ 6-12 taksit se√ßenekleri"
        
        dispatcher.utter_message(text=message)
        
        return []


class ActionProvideClinicDetails(Action):
    """Klinik detaylarƒ±nƒ± g√∂ster - API Client kullanƒ±yor"""
    
    def name(self) -> Text:
        return "action_provide_clinic_details"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        klinik_adi = tracker.get_slot("klinik_adi")
        
        if not klinik_adi:
            dispatcher.utter_message(text="L√ºtfen klinik adƒ±nƒ± belirtin.")
            return []
        
        try:
            # ‚úÖ API CLIENT KULLAN - T√ºm klinikleri ara
            response = clinic_client.search_clinics(
                treatment_type=None,  # T√ºm kategoriler
                city=None,            # T√ºm ≈üehirler
                treatment_name=None   # T√ºm tedaviler
            )
            
            all_clinics = response.get("results", [])
            
            # Klinik adƒ±na g√∂re filtrele
            clinic_found = None
            for clinic in all_clinics:
                if clinic["name"].lower() == klinik_adi.lower():
                    clinic_found = clinic
                    break
                # Kƒ±smi e≈üle≈üme de kontrol et
                elif klinik_adi.lower() in clinic["name"].lower():
                    clinic_found = clinic
                    break
            
            if clinic_found:
                message = f"üè• **{clinic_found['name']}**\n\n"
                message += f"üìç Adres: {clinic_found.get('address', 'Belirtilmemi≈ü')}\n"
                message += f"üèôÔ∏è ≈ûehir: {clinic_found.get('city', 'N/A')}\n"
                message += f"üìå ƒ∞l√ße: {clinic_found.get('district', 'N/A')}\n"
                message += f"‚≠ê Rating: {clinic_found.get('rating', 0)}/5.0\n"
                
                if 'accreditations' in clinic_found:
                    message += f"üèÜ Akreditasyonlar: {', '.join(clinic_found['accreditations'])}\n"
                
                if 'languages' in clinic_found:
                    message += f"üåç Diller: {', '.join(clinic_found['languages'])}\n"
                
                message += f"\nüíâ **Tedaviler:**\n"
                treatments = clinic_found.get('treatments', [])
                for treatment in treatments[:8]:  # ƒ∞lk 8 tedavi
                    message += f"‚Ä¢ {treatment}\n"
                
                if len(treatments) > 8:
                    message += f"‚Ä¢ ve {len(treatments) - 8} tedavi daha...\n"
                
                message += f"\nüí∞ Fiyat Aralƒ±ƒüƒ±: {clinic_found.get('price_range', 'Standart').title()}\n"
                message += f"\nüìû Randevu almak i√ßin bize ula≈üƒ±n!"
                
                dispatcher.utter_message(text=message)
            else:
                # Klinik bulunamadƒ±, alternatif √∂ner
                message = f"√úzg√ºn√ºm, '{klinik_adi}' adlƒ± klinik bulunamadƒ±.\n\n"
                message += "‚úÖ ≈ûunlarƒ± deneyebilirsiniz:\n"
                message += "‚Ä¢ Klinik adƒ±nƒ± tam olarak yazƒ±n\n"
                message += "‚Ä¢ Tedavi t√ºr√º ve ≈üehir belirtin\n"
                message += "‚Ä¢ √ñrnek: 'Antalya'da di≈ü kliniƒüi'\n\n"
                
                # ƒ∞lk 3 kliniƒüi √∂neri olarak g√∂ster
                if all_clinics:
                    message += "üìç **Pop√ºler Kliniklerimiz:**\n"
                    for clinic in all_clinics[:3]:
                        message += f"‚Ä¢ {clinic['name']} ({clinic.get('city', 'Antalya')})\n"
                
                dispatcher.utter_message(text=message)
        
        except Exception as e:
            logger.error(f"‚ùå Klinik detay hatasƒ±: {e}")
            dispatcher.utter_message(
                text="‚ö†Ô∏è Klinik bilgileri alƒ±nƒ±rken bir hata olu≈ütu. L√ºtfen tekrar deneyin."
            )
        
        return []


class ActionSaveUserProfile(Action):
    """Kullanƒ±cƒ± profilini kaydet"""
    
    def name(self) -> Text:
        return "action_save_user_profile"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        user_profile = {
            "user_name": tracker.get_slot("user_name"),
            "yas": tracker.get_slot("yas"),
            "cinsiyet": tracker.get_slot("cinsiyet"),
            "hastalik": tracker.get_slot("hastalik"),
            "saglik_durumu": tracker.get_slot("saglik_durumu"),
            "timestamp": datetime.now().isoformat()
        }
        
        # Veritabanƒ±na kaydetme sim√ºlasyonu
        # Ger√ßek uygulamada database API kullanƒ±lacak
        
        dispatcher.utter_message(text="‚úÖ Bilgileriniz g√ºvenle kaydedildi.")
        
        return []


class ActionScheduleAppointment(Action):
    """Randevu planla"""
    
    def name(self) -> Text:
        return "action_schedule_appointment"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        klinik_adi = tracker.get_slot("klinik_adi")
        tarih = tracker.get_slot("tarih")
        tedavi_adi = tracker.get_slot("tedavi_adi")
        
        # Randevu API √ßaƒürƒ±sƒ± sim√ºlasyonu
        
        message = f"‚úÖ Randevunuz olu≈üturuldu!\n\n"
        message += f"üè• Klinik: {klinik_adi or 'Se√ßilecek'}\n"
        message += f"üíâ Tedavi: {tedavi_adi or 'Belirtilecek'}\n"
        message += f"üìÖ Tarih: {tarih or 'Planlanacak'}\n\n"
        message += f"üìß Detaylƒ± bilgilendirme e-posta adresinize g√∂nderilecektir.\n"
        message += f"üì± Koordinat√∂r√ºm√ºz 24 saat i√ßinde sizinle ileti≈üime ge√ßecektir."
        
        dispatcher.utter_message(text=message)
        
        return []


class ValidateUserBudget(Action):
    """Kullanƒ±cƒ± b√ºt√ßesini doƒürula"""
    
    def name(self) -> Text:
        return "validate_user_budget"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        butce = tracker.get_slot("butce")
        
        if butce:
            # B√ºt√ßeden sayƒ±sal deƒüer √ßƒ±kar
            import re
            numbers = re.findall(r'\d+', str(butce))
            
            if numbers:
                budget_value = int(numbers[0])
                
                if budget_value < 2000:
                    message = "üí° Belirttiƒüiniz b√ºt√ße i√ßin ekonomik paketlerimiz mevcut. "
                    message += "Daha fazla se√ßenek i√ßin b√ºt√ßenizi artƒ±rabilir veya √∂deme planlarƒ±mƒ±zdan yararlanabilirsiniz."
                    dispatcher.utter_message(text=message)
                elif budget_value > 15000:
                    message = "üëë Premium ve l√ºks paketlerimizle size en iyi hizmeti sunabiliriz!"
                    dispatcher.utter_message(text=message)
        
        return []


class ValidateTreatmentCompatibility(Action):
    """Tedavi uyumluluƒüunu kontrol et"""
    
    def name(self) -> Text:
        return "validate_treatment_compatibility"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        hastalik = tracker.get_slot("hastalik")
        tedavi_adi = tracker.get_slot("tedavi_adi")
        yas = tracker.get_slot("yas")
        
        # Basit uyumluluk kontrol√º
        warnings = []
        
        if hastalik:
            if "diabetes" in str(hastalik).lower() or "diyabet" in str(hastalik).lower():
                warnings.append("‚ö†Ô∏è Diyabet hastalarƒ±nda √∂zel tedavi protokol√º uygulanƒ±r.")
            
            if "hypertension" in str(hastalik).lower() or "hipertansiyon" in str(hastalik).lower():
                warnings.append("‚ö†Ô∏è Tansiyon takibi ameliyat s√ºrecinde yapƒ±lacaktƒ±r.")
        
        if yas:
            try:
                age = int(yas)
                if age > 70:
                    warnings.append("‚ÑπÔ∏è Ya≈üƒ±nƒ±z nedeniyle ek saƒülƒ±k kontrolleri gerekebilir.")
            except:
                pass
        
        if warnings:
            message = "üè• **Saƒülƒ±k Durumu Bildirimi:**\n\n"
            message += "\n".join(warnings)
            message += "\n\nDoktorlarƒ±mƒ±z sizinle g√∂r√º≈üme sonrasƒ± en uygun tedavi planƒ±nƒ± belirleyecektir."
            dispatcher.utter_message(text=message)
        
        return []


class ActionGenerateReport(Action):
    """Raporlama sistemi - Payda≈ülar i√ßin"""
    
    def name(self) -> Text:
        return "action_generate_report"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        # Bu action genellikle admin/payda≈ü panelinden √ßaƒürƒ±lƒ±r
        # √ñrnek rapor t√ºrleri:
        # 1. Hasta sayƒ±sƒ± ve demografik analiz
        # 2. Pop√ºler tedavi t√ºrleri
        # 3. Klinik performans skorlarƒ±
        # 4. Gelir analizi
        # 5. M√º≈üteri memnuniyet skorlarƒ±
        
        return []


class ActionDefaultFallback(Action):
    """
    Default fallback action - Rasa anlayamadƒ±ƒüƒ±nda √ßalƒ±≈üƒ±r
    """
    
    def name(self) -> Text:
        return "action_default_fallback"
    
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        user_message = tracker.latest_message.get('text', '')
        logger.info(f"ü§∑ Default fallback triggered: '{user_message}'")
        
        # Kullanƒ±cƒ±ya yardƒ±mcƒ± mesaj g√∂ster
        message = "√úzg√ºn√ºm, tam olarak anlayamadƒ±m. ü§î\n\n"
        message += "‚ú® ≈ûunlarƒ± deneyebilirsiniz:\n"
        message += "‚Ä¢ 'Antalya'da di≈ü kliniƒüi'\n"
        message += "‚Ä¢ 'ƒ∞stanbul'da rinoplasti'\n"
        message += "‚Ä¢ 'Otel √∂nerisi'\n"
        message += "‚Ä¢ 'Fiyat bilgisi'\n\n"
        message += "Ya da bana doƒürudan sorunuzu yazabilirsiniz."
        
        dispatcher.utter_message(text=message)
        
        return []
